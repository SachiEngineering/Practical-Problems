
'''
Conway's Game Of Life

Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) is a famous example of a cellular automaton devised as a thought experiment for modeling local populations and other networks.

The game takes an initial state which is a matrix of booleans. True represents a live cell. False is dead. On every turn, each cell computes it's next state based on its own state and that of its neighbors along horizontals, verticals, or diagonals. The rules are:

- Any live cell with fewer than two live neighbors dies, as if by underpopulation.
- Any live cell with two or three live neighbors lives on to the next generation.
- Any live cell with more than three live neighbors dies, as if by overpopulation.
- Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

For ease of viewing the states, we'll use strings instead of booleans. An "X" will represent a live cell, a space will represent a dead cell.
 

EXAMPLE(S)
blinker = [
  [" ", " ", " ", " ", " "],
  [" ", " ", "X", " ", " "],
  [" ", " ", "X", " ", " "],
  [" ", " ", "X", " ", " "],
  [" ", " ", " ", " ", " "],
]

conway(blinker, 1) =>
[
  [ ' ', ' ', ' ', ' ', ' ' ],
  [ ' ', ' ', ' ', ' ', ' ' ],
  [ ' ', 'X', 'X', 'X', ' ' ],
  [ ' ', ' ', ' ', ' ', ' ' ],
  [ ' ', ' ', ' ', ' ', ' ' ]
]
conway(blinker, 2) =>
[
  [ ' ', ' ', ' ', ' ', ' ' ],
  [ ' ', ' ', 'X', ' ', ' ' ],
  [ ' ', ' ', 'X', ' ', ' ' ],
  [ ' ', ' ', 'X', ' ', ' ' ],
  [ ' ', ' ', ' ', ' ', ' ' ]
]

Notice that this pattern cycles between horizontal and vertical orientations. Look in the the wikipedia article for more interesting and well known patterns! 
 

FUNCTION SIGNATURE
function conway(board, rounds) {
def conway(board, rounds):
'''

def conway(board, rounds):
    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]

    def countNeighbors(board,x,y):
      count = 0
      for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(board) and 0 <= ny < len(board[0]):
          if board[nx][ny] == 'X':
            count += 1
      return count

    def createBoard(board):
        newBoard = []

        #for each cell in the board
        for i in range(len(board)):#each row
            row = []
            for j in range(len(board[0])):#each col
                
                #count neighbors
                liveNeighbors = countNeighbors(board,i,j)
                
                #apply rules
                #  Any live cell with fewer than two live neighbors dies, as if by underpopulation.
                # - Any live cell with two or three live neighbors lives on to the next generation.
                # - Any live cell with more than three live neighbors dies, as if by overpopulation.
                # - Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

                if board[i][j] == "X": #if alive
                    if liveNeighbors <2 or liveNeighbors>3:
                        row.append(' ') #live to dead
                    else:
                        row.append("X")
                else: #dead
                    if liveNeighbors == 3:
                        row.append("X") #dead to live
                    else:
                        row.append(" ")
            newBoard.append(row)
        return newBoard

    #create new board for every round
    current = board
    for x in range(rounds):
        current = createBoard(current)
        
    return current

# Verify
blinker = [
  [" ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " "],
  [" ", " ", "X", "X", "X", " "],
  [" ", "X", "X", "X", " ", " "],
  [" ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " "],
]

result = conway(blinker, 1)
for each in result:
    print(each)
