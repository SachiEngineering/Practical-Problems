
'''
Suggest Meeting Times

You've been asked to write a function that finds all available time slots for scheduling a meeting between a group of people. The function should take as input a dictionary of schedules, where each key represents a person and the value is a list of busy intervals during the workday. The busy intervals are represented as tuples of start and end times. For example, the following schedule shows that Alice is busy from 8am to 10am and from 1pm to 2pm, while Bob is busy from 9am to 11am and from 2pm to 3pm:

schedules = {
    'Alice': [(8, 10), (13, 14)],
    'Bob': [(9, 11), (14, 15)],
}

The function should also take as input the duration of the meeting in hours, and should return a list of all available time slots during the workday where the meeting can be scheduled. A workday begins at 8am and ends at 5pm. A time slot is represented as a single integer that represents the start time of the slot in hours past midnight.

Your task is to implement the find_available_slots function that takes these inputs and returns the list of available time slots. Be sure to consider edge cases, such as when there are no busy intervals, when the meeting duration is longer than the workday, and when multiple start times are possible within a single free interval.
 

EXAMPLE(S)
schedules = {
    'Alice': [(8, 10), (13, 14)],
    'Bob': [(9, 11), (14, 15)],
}

For example, if the meeting duration is 2 hours and the workday is from 8am to 5pm, the available time slots for the above schedule would be [11, 15], since those are the only times where both Alice and Bob are available for a meeting of 2 hours.
 

FUNCTION SIGNATURE
find_available_slots(schedules: dict, duration: int) -> list:
'''


def find_available_slots(schedules, duration):
    begin = 8
    end = 17
    combined_times =[]
    for worker in schedules.keys():
       combined_times.extend(schedules[worker])

    combined_times.sort() # put in order
   

    #merge common busy times
    mergedTimes = []
    for interval in combined_times:
        #if there isn't anything inside or no overlap
        if not mergedTimes or mergedTimes[-1][1] < interval[0]:
            mergedTimes.append(interval)

        #there is overlap
        else:
            #change the end.
            mergedTimes[-1] = (mergedTimes[-1][0], max(mergedTimes[-1][1], interval[1]))

    free_intervals = []
    for start, stop in mergedTimes:
        if begin + duration <= start:
            free_intervals.append(begin)
        begin = max(begin, stop)
    if begin + duration <= end:
        free_intervals.append(begin)

    return free_intervals
    

schedules = {
    'Alice': [(8, 10), (13, 14)],
    'Bob': [(9, 11), (14, 15)],
}
duration = 2
        
print(find_available_slots(schedules, duration))
